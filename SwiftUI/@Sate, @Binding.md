
# @State (상태)
## SwiftUI에서 관리하는 값을 읽고 쓸 수 있는 속성 래퍼 유형이다.
SwiftUI에서는 기본적으로 구조체에서 View프로토콜을 구현하여 View(사용자 화면)를 다룬다. Xcode에서 프로젝트를 만들 때 SwiftUI를 선택하면 ContentView 구조체가 생성되고 여기서 뷰를 다룬다.

그런데 구조체 안에서 var 키워드로 선언한 프로퍼티의 값을 구조체 내(보통 body 프로퍼티)에서 변경하려고 하면 에러가 뜬다. 

### 왜 그런 것일까??

Swift의 구조체에서 mutating으로 선언되지 않은 연산 프로퍼티는 구조체 내부에서 그 값의 변경이 불가하다. 그렇다고 연산 프로퍼티인 body를 mutating으로 선언해줘서도 안된다.

View프로토콜의 body 프로퍼티는 {get} 으로 되어 있으며, 이는 nonmutating으로 구현을 요구한다. 그렇다면 변수 변경은 아예 불가능할까?? 

### @State라는 속성을 이용하면 가능하다.

@State는 단어 그대로 현재 상태를 나타내는 속성으로써 뷰의 상태(예를 들어 토글 버튼이 활성화되었는지 여부, 텍스트 필드에 입력된 텍스트, 또는 피커 뷰에서의 현재 선택)를 저장하는 데 사용한다. 상태 프로퍼티는 String이나 Int 값처럼 간단한 데이터 타입을 저장하기 위해 사용되며, @State 프로퍼티 래퍼를 사용하여 선언된다. 그리고 현재 뷰 ui의 특정 상태를 저장하기 위해 만들어진 것이기 때문에 보통 Private로 지정하여 사용한다.  

상태 프로퍼티 값이 변경되었다는 것은 그 프로퍼티가 선언된 뷰 계층 구조를 다시 랜더링해야 한다는 SwiftUI 신호다. 즉, 그 계층구조 안에 있는 모든 뷰를 빠르게 재생성하고 표시해야 한다. 결국, 그 프로퍼티에 의존하는 모든 뷰는 어떤 식으로는 최신 값이 반영되도록 업데이트 된다.

상태 프로퍼티를 선언 했다면 레이아웃에 있는 뷰와 바인딩을 할 수 있다. 바인딩이 되어 있는 뷰에서 어떤 변경이 일어나면 해당 상태 프로퍼티에 자동으로 반영된다. 

# @Binding (상태 바인딩)
상태 프로퍼티는 선언된 뷰와 그 하위 뷰에 대한 현재 값이다. 하지만, 어떤 뷰가 하나 이상의 하위 뷰를 가지고 있으며 동일한 상태 프로퍼티에 대해 접근해야 하는 경우가 발새한다.

이문제는 @Binding 프로퍼티 래퍼를 이용하여 프로퍼티를 선언하면 해결된다.

@Binding은 단어 그대로 구속력이 있는, 묶여 있는 뜻이다. @State 속성으로 선언된 프로퍼티와 연결되어 있다고 생각하면 된다. 다른 뷰에서 해당 프로퍼티를 사용한다면 @Binding 속성을 사용하면 된다.

@State는 반드시 주가 되는 뷰에 한 번 선언해주고, 이 프로퍼티를 다른 뷰들에서 사용하기 위해서는 @Binding을 사용한다. 그리고 사용시에는 $를 앞에 붙어주어 Binding 변수임을 나타낸다.
